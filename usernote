rust-objdump -S target/riscv64gc-unknown-none-elf/debug/os
qemu-riscv64 target/riscv64gc-unknown-none-elf/debug/os

使用如下命令来启动 Qemu 并运行我们的内核：
qemu-system-riscv64 \
            -machine virt \
            -nographic \
            -bios $(BOOTLOADER) \
            -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA)

-machine virt 表示将模拟的 64 位 RISC-V 计算机设置为名为 virt 的虚拟计算机。我们知道，即使同属同一种指令集架构，也会有很多种不同的计算机配置，比如 CPU 的生产厂商和型号不同，支持的 I/O 外设种类也不同。关于 virt 平台的更多信息可以参考 1 。Qemu 还支持模拟其他 RISC-V 计算机，其中包括由 SiFive 公司生产的著名的 HiFive Unleashed 开发板。
-nographic 表示模拟器不需要提供图形界面，而只需要对外输出字符流。
通过 -bios 可以设置 Qemu 模拟器开机时用来初始化的引导加载程序（bootloader），这里我们使用预编译好的 rustsbi-qemu.bin ，它需要被放在与 os 同级的 bootloader 目录下，该目录可以从每一章的代码分支中获得。
通过虚拟设备 -device 中的 loader 属性可以在 Qemu 模拟器开机之前将一个宿主机上的文件载入到 Qemu 的物理内存的指定位置中， file 和 addr 属性分别可以设置待载入文件的路径以及将文件载入到的 Qemu 物理内存上的物理地址。这里我们载入的 os.bin 被称为 内核镜像 ，它会被载入到 Qemu 模拟器内存的 0x80200000 地址处。 那么内核镜像 os.bin 是怎么来的呢？上一节中我们移除标准库依赖后会得到一个内核可执行文件 os ，将其进一步处理就能得到 os.bin ，具体处理流程我们会在后面深入讨论。

使用如下命令可以丢弃内核可执行文件中的元数据得到内核镜像：
rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin